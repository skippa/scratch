!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/a3c87ab5/
<Plug>(coc-codeaction)	s.vim	/^nnoremap <Plug>(coc-codeaction) :call       CocActionAsync('codeAction',         '')$/;"	m
<Plug>(coc-codeaction-selected)	s.vim	/^vnoremap <Plug>(coc-codeaction-selected) :call       CocActionAsync('codeAction',         visu/;"	m
<Plug>(coc-codelens-action)	s.vim	/^nnoremap <Plug>(coc-codelens-action) :call       CocActionAsync('codeLensAction')$/;"	m
<Plug>(coc-command-repeat)	s.vim	/^nnoremap <Plug>(coc-command-repeat) :call       CocAction('repeatCommand')$/;"	m
<Plug>(coc-cursors-position)	s.vim	/^nnoremap <silent> <Plug>(coc-cursors-position) :call coc#rpc#request('cursorsSelect', [bufnr('/;"	m
<Plug>(coc-cursors-range)	s.vim	/^vnoremap <silent> <Plug>(coc-cursors-range) :call coc#rpc#request('cursorsSelect', [bufnr('%')/;"	m
<Plug>(coc-cursors-word)	s.vim	/^nnoremap <silent> <Plug>(coc-cursors-word) :call coc#rpc#request('cursorsSelect', [bufnr('%'),/;"	m
<Plug>(coc-declaration)	s.vim	/^nnoremap <Plug>(coc-declaration) :call       CocAction('jumpDeclaration')$/;"	m
<Plug>(coc-definition)	s.vim	/^nnoremap <Plug>(coc-definition) :call       CocAction('jumpDefinition')$/;"	m
<Plug>(coc-diagnostic-info)	s.vim	/^nnoremap <Plug>(coc-diagnostic-info) :call       CocActionAsync('diagnosticInfo')$/;"	m
<Plug>(coc-diagnostic-next)	s.vim	/^nnoremap <Plug>(coc-diagnostic-next) :call       CocActionAsync('diagnosticNext')$/;"	m
<Plug>(coc-diagnostic-next-error)	s.vim	/^nnoremap <Plug>(coc-diagnostic-next-error) :call       CocActionAsync('diagnosticNext',     'e/;"	m
<Plug>(coc-diagnostic-prev)	s.vim	/^nnoremap <Plug>(coc-diagnostic-prev) :call       CocActionAsync('diagnosticPrevious')$/;"	m
<Plug>(coc-diagnostic-prev-error)	s.vim	/^nnoremap <Plug>(coc-diagnostic-prev-error) :call       CocActionAsync('diagnosticPrevious', 'e/;"	m
<Plug>(coc-fix-current)	s.vim	/^nnoremap <Plug>(coc-fix-current) :call       CocActionAsync('doQuickfix')$/;"	m
<Plug>(coc-float-hide)	s.vim	/^nnoremap <Plug>(coc-float-hide) :call       coc#util#float_hide()$/;"	m
<Plug>(coc-float-jump)	s.vim	/^nnoremap <Plug>(coc-float-jump) :call       coc#util#float_jump()$/;"	m
<Plug>(coc-format)	s.vim	/^nnoremap <Plug>(coc-format) :call       CocActionAsync('format')$/;"	m
<Plug>(coc-format-selected)	s.vim	/^vnoremap <Plug>(coc-format-selected) :call       CocActionAsync('formatSelected',     visualmo/;"	m
<Plug>(coc-funcobj-a)	s.vim	/^onoremap <silent> <Plug>(coc-funcobj-a) :call coc#rpc#request('selectFunction', [v:false, ''])/;"	m
<Plug>(coc-funcobj-a)	s.vim	/^vnoremap <silent> <Plug>(coc-funcobj-a) :call coc#rpc#request('selectFunction', [v:false, visu/;"	m
<Plug>(coc-funcobj-i)	s.vim	/^onoremap <silent> <Plug>(coc-funcobj-i) :call coc#rpc#request('selectFunction', [v:true, ''])$/;"	m
<Plug>(coc-funcobj-i)	s.vim	/^vnoremap <silent> <Plug>(coc-funcobj-i) :call coc#rpc#request('selectFunction', [v:true, visua/;"	m
<Plug>(coc-implementation)	s.vim	/^nnoremap <Plug>(coc-implementation) :call       CocAction('jumpImplementation')$/;"	m
<Plug>(coc-openlink)	s.vim	/^nnoremap <Plug>(coc-openlink) :call       CocActionAsync('openLink')$/;"	m
<Plug>(coc-range-select)	s.vim	/^nnoremap <Plug>(coc-range-select) :call       CocAction('rangeSelect',     '', v:true)$/;"	m
<Plug>(coc-range-select)	s.vim	/^vnoremap <Plug>(coc-range-select) :call       CocAction('rangeSelect',     visualmode(), v:tru/;"	m
<Plug>(coc-range-select-backward)	s.vim	/^vnoremap <Plug>(coc-range-select-backward) :call       CocAction('rangeSelect',     visualmode/;"	m
<Plug>(coc-refactor)	s.vim	/^nnoremap <Plug>(coc-refactor) :call       CocActionAsync('refactor')$/;"	m
<Plug>(coc-references)	s.vim	/^nnoremap <Plug>(coc-references) :call       CocAction('jumpReferences')$/;"	m
<Plug>(coc-rename)	s.vim	/^nnoremap <Plug>(coc-rename) :call       CocActionAsync('rename')$/;"	m
<Plug>(coc-type-definition)	s.vim	/^nnoremap <Plug>(coc-type-definition) :call       CocAction('jumpTypeDefinition')$/;"	m
<Plug>CocRefresh	s.vim	/^inoremap <silent> <Plug>CocRefresh =coc#_complete()$/;"	m
<Plug>NetrwBrowseX	s.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX/;"	m
<Plug>NetrwBrowseXVis	s.vim	/^vnoremap <silent> <Plug>NetrwBrowseXVis :call netrw#BrowseXVis()$/;"	m
Animate:init	Animate.lua	/^function Animate:init(spriteSheet, frameX, frameY, duration)$/;"	f
Animate:render	Animate.lua	/^function Animate:render()$/;"	f
Animate:update	Animate.lua	/^function Animate:update(dt)$/;"	f
Animation:clone	anim8.lua	/^function Animation:clone()$/;"	f
Animation:draw	anim8.lua	/^function Animation:draw(image, x, y, r, sx, sy, ox, oy, kx, ky)$/;"	f
Animation:flipH	anim8.lua	/^function Animation:flipH()$/;"	f
Animation:flipV	anim8.lua	/^function Animation:flipV()$/;"	f
Animation:getDimensions	anim8.lua	/^function Animation:getDimensions()$/;"	f
Animation:getFrameInfo	anim8.lua	/^function Animation:getFrameInfo(x, y, r, sx, sy, ox, oy, kx, ky)$/;"	f
Animation:gotoFrame	anim8.lua	/^function Animation:gotoFrame(position)$/;"	f
Animation:init	Animation.lua	/^function Animation:init(image, width, height, duration)$/;"	f
Animation:pause	anim8.lua	/^function Animation:pause()$/;"	f
Animation:pauseAtEnd	anim8.lua	/^function Animation:pauseAtEnd()$/;"	f
Animation:pauseAtStart	anim8.lua	/^function Animation:pauseAtStart()$/;"	f
Animation:render	Animation.lua	/^function Animation:render()$/;"	f
Animation:resume	anim8.lua	/^function Animation:resume()$/;"	f
Animation:update	Animation.lua	/^function Animation:update(dt)$/;"	f
Animation:update	anim8.lua	/^function Animation:update(dt)$/;"	f
Bird:init	Bird.lua	/^function Bird:init()$/;"	f
Bird:render	Bird.lua	/^function Bird:render()$/;"	f
Bird:update	Bird.lua	/^function Bird:update(dt)$/;"	f
Class:extend	class.lua	/^function Class:extend(obj)$/;"	f
Class:init	class.lua	/^function Class:init(...) end$/;"	f
Class:new	class.lua	/^function Class:new(...)$/;"	f
Class:set	class.lua	/^function Class:set(prop, value)$/;"	f
Grid:getFrames	anim8.lua	/^function Grid:getFrames(...)$/;"	f
SessionLoad	s.vim	/^let SessionLoad = 1$/;"	v
Tiles:getCurrentTile	Tiles.lua	/^function Tiles:getCurrentTile(x, y)$/;"	f
Tiles:getTileXY	Tiles.lua	/^function Tiles:getTileXY(thisTile)$/;"	f
Tiles:init	Tiles.lua	/^function Tiles:init(tileSheet, tileWidth, tileHeight)$/;"	f
Tiles:isonGround	Tiles.lua	/^function Tiles:isonGround(x, y)$/;"	f
Tiles:render	Tiles.lua	/^function Tiles:render()$/;"	f
World:add	bump.lua	/^function World:add(item, x,y,w,h)$/;"	f
World:addResponse	bump.lua	/^function World:addResponse(name, response)$/;"	f
World:check	bump.lua	/^function World:check(item, goalX, goalY, filter)$/;"	f
World:countCells	bump.lua	/^function World:countCells()$/;"	f
World:countItems	bump.lua	/^function World:countItems()$/;"	f
World:getItems	bump.lua	/^function World:getItems()$/;"	f
World:getRect	bump.lua	/^function World:getRect(item)$/;"	f
World:hasItem	bump.lua	/^function World:hasItem(item)$/;"	f
World:move	bump.lua	/^function World:move(item, goalX, goalY, filter)$/;"	f
World:project	bump.lua	/^function World:project(item, x,y,w,h, goalX, goalY, filter)$/;"	f
World:queryPoint	bump.lua	/^function World:queryPoint(x,y, filter)$/;"	f
World:queryRect	bump.lua	/^function World:queryRect(x,y,w,h, filter)$/;"	f
World:querySegment	bump.lua	/^function World:querySegment(x1, y1, x2, y2, filter)$/;"	f
World:querySegmentWithCoords	bump.lua	/^function World:querySegmentWithCoords(x1, y1, x2, y2, filter)$/;"	f
World:remove	bump.lua	/^function World:remove(item)$/;"	f
World:toCell	bump.lua	/^function World:toCell(x,y)$/;"	f
World:toWorld	bump.lua	/^function World:toWorld(cx, cy)$/;"	f
World:update	bump.lua	/^function World:update(item, x2,y2,w2,h2)$/;"	f
\\l	s.vim	/^map \\l :wa!$/;"	m
\\n	s.vim	/^map \\n :NERDTreeToggle$/;"	m
addItemToCell	bump.lua	/^local function addItemToCell(self, item, cx, cy)$/;"	f
assertIsPositiveNumber	bump.lua	/^local function assertIsPositiveNumber(value, name)$/;"	f
assertIsRect	bump.lua	/^local function assertIsRect(x,y,w,h)$/;"	f
assertPositiveInteger	anim8.lua	/^local function assertPositiveInteger(value, name)$/;"	f
assertType	bump.lua	/^local function assertType(desiredType, value, name)$/;"	f
bounce	bump.lua	/^local bounce = function(world, col, x,y,w,h, goalX, goalY, filter)$/;"	f
bump.newWorld	bump.lua	/^bump.newWorld = function(cellSize)$/;"	f
class	class.lua	/^function class(attr)$/;"	f
cloneArray	anim8.lua	/^local function cloneArray(arr)$/;"	f
copyTable	class.lua	/^	local function copyTable(table, destination)$/;"	f
createFrame	anim8.lua	/^local function createFrame(self, x, y)$/;"	f
cross	bump.lua	/^local cross = function(world, col, x,y,w,h, goalX, goalY, filter)$/;"	f
defaultFilter	bump.lua	/^local defaultFilter = function()$/;"	f
f	anim8.lua	/^    local f = type(self.onLoop) == 'function' and self.onLoop or self[self.onLoop]$/;"	f
getCellsTouchedBySegment	bump.lua	/^local function getCellsTouchedBySegment(self, x1,y1,x2,y2)$/;"	f
getDictItemsInCellRect	bump.lua	/^local function getDictItemsInCellRect(self, cl,ct,cw,ch)$/;"	f
getGridKey	anim8.lua	/^local function getGridKey(...)$/;"	f
getInfoAboutItemsTouchedBySegment	bump.lua	/^local function getInfoAboutItemsTouchedBySegment(self, x1,y1, x2,y2, filter)$/;"	f
getOrCreateFrame	anim8.lua	/^local function getOrCreateFrame(self, x, y)$/;"	f
getResponseByName	bump.lua	/^local function getResponseByName(self, name)$/;"	f
grid_toCell	bump.lua	/^local function grid_toCell(cellSize, x, y)$/;"	f
grid_toCellRect	bump.lua	/^local function grid_toCellRect(cellSize, x,y,w,h)$/;"	f
grid_toWorld	bump.lua	/^local function grid_toWorld(cellSize, cx, cy)$/;"	f
grid_traverse	bump.lua	/^local function grid_traverse(cellSize, x1,y1,x2,y2, f)$/;"	f
grid_traverse_initStep	bump.lua	/^local function grid_traverse_initStep(cellSize, ct, t1, t2)$/;"	f
gx	s.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
gx	s.vim	/^vmap gx <Plug>NetrwBrowseXVis$/;"	m
love.draw	main.lua	/^function love.draw()$/;"	f
love.keypressed	main.lua	/^function love.keypressed(key)$/;"	f
love.load	main.lua	/^function love.load()$/;"	f
love.resize	main.lua	/^function love.resize(w, h)$/;"	f
love.update	main.lua	/^function love.update(dt)$/;"	f
mt.__call	class.lua	/^	mt.__call = function(self, ...)$/;"	f
mt.__index	class.lua	/^	mt.__index = function(table, key)$/;"	f
mt.__newindex	class.lua	/^	mt.__newindex = function(table, key, value)$/;"	f
nearest	bump.lua	/^local function nearest(x, a, b)$/;"	f
newAnimation	anim8.lua	/^local function newAnimation(frames, durations, onLoop)$/;"	f
newGrid	anim8.lua	/^local function newGrid(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)$/;"	f
nop	anim8.lua	/^local nop = function() end$/;"	f
parseDurations	anim8.lua	/^local function parseDurations(durations, frameCount)$/;"	f
parseInterval	anim8.lua	/^local function parseInterval(str)$/;"	f
parseIntervals	anim8.lua	/^local function parseIntervals(durations)$/;"	f
push:addCanvas	push.lua	/^function push:addCanvas(params)$/;"	f
push:apply	push.lua	/^function push:apply(operation, shader)$/;"	f
push:applySettings	push.lua	/^function push:applySettings(settings)$/;"	f
push:applyShaders	push.lua	/^function push:applyShaders(canvas, shaders)$/;"	f
push:finish	push.lua	/^function push:finish(shader)$/;"	f
push:getCanvasTable	push.lua	/^function push:getCanvasTable(name)$/;"	f
push:getDimensions	push.lua	/^function push:getDimensions() return self._WWIDTH, self._WHEIGHT end$/;"	f
push:getHeight	push.lua	/^function push:getHeight() return self._WHEIGHT end$/;"	f
push:getWidth	push.lua	/^function push:getWidth() return self._WWIDTH end$/;"	f
push:initValues	push.lua	/^function push:initValues()$/;"	f
push:resetSettings	push.lua	/^function push:resetSettings() return self:applySettings(self.defaults) end$/;"	f
push:resize	push.lua	/^function push:resize(w, h)$/;"	f
push:setBorderColor	push.lua	/^function push:setBorderColor(color, g, b)$/;"	f
push:setCanvas	push.lua	/^function push:setCanvas(name)$/;"	f
push:setShader	push.lua	/^function push:setShader(name, shader)$/;"	f
push:setupCanvas	push.lua	/^function push:setupCanvas(canvases)$/;"	f
push:setupScreen	push.lua	/^function push:setupScreen(WWIDTH, WHEIGHT, RWIDTH, RHEIGHT, settings)$/;"	f
push:start	push.lua	/^function push:start()$/;"	f
push:switchFullscreen	push.lua	/^function push:switchFullscreen(winw, winh)$/;"	f
push:toGame	push.lua	/^function push:toGame(x, y)$/;"	f
push:toReal	push.lua	/^function push:toReal(x, y)$/;"	f
rect_containsPoint	bump.lua	/^local function rect_containsPoint(x,y,w,h, px,py)$/;"	f
rect_detectCollision	bump.lua	/^local function rect_detectCollision(x1,y1,w1,h1, x2,y2,w2,h2, goalX, goalY)$/;"	f
rect_getDiff	bump.lua	/^local function rect_getDiff(x1,y1,w1,h1, x2,y2,w2,h2)$/;"	f
rect_getNearestCorner	bump.lua	/^local function rect_getNearestCorner(x,y,w,h, px, py)$/;"	f
rect_getSegmentIntersectionIndices	bump.lua	/^local function rect_getSegmentIntersectionIndices(x,y,w,h, x1,y1,x2,y2, ti1,ti2)$/;"	f
rect_getSquareDistance	bump.lua	/^local function rect_getSquareDistance(x1,y1,w1,h1, x2,y2,w2,h2)$/;"	f
rect_isIntersecting	bump.lua	/^local function rect_isIntersecting(x1,y1,w1,h1, x2,y2,w2,h2)$/;"	f
removeItemFromCell	bump.lua	/^local function removeItemFromCell(self, item, cx, cy)$/;"	f
s:cpo_save	s.vim	/^let s:cpo_save=&cpo$/;"	v
s:l	s.vim	/^let s:l = 11 - ((10 * winheight(0) + 11) \/ 23)$/;"	v
s:l	s.vim	/^let s:l = 15 - ((14 * winheight(0) + 11) \/ 23)$/;"	v
s:l	s.vim	/^let s:l = 4 - ((1 * winheight(0) + 11) \/ 23)$/;"	v
s:so_save	s.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:sx	s.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:wipebuf	s.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
scratch	README.md	/^# scratch$/;"	c
seekFrameIndex	anim8.lua	/^local function seekFrameIndex(intervals, timer)$/;"	f
sign	bump.lua	/^local function sign(x)$/;"	f
slide	bump.lua	/^local slide = function(world, col, x,y,w,h, goalX, goalY, filter)$/;"	f
sortByTiAndDistance	bump.lua	/^local function sortByTiAndDistance(a,b)$/;"	f
sortByWeight	bump.lua	/^local function sortByWeight(a,b) return a.weight < b.weight end$/;"	f
touch	bump.lua	/^local touch = function(world, col, x,y,w,h, goalX, goalY, filter)$/;"	f
visitedFilter	bump.lua	/^  local visitedFilter = function(itm, other)$/;"	f
windowUpdateMode	push.lua	/^local windowUpdateMode = love11 and love.window.updateMode or function(width, height, settings)$/;"	f
