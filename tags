!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/a3c87ab5/
,py	s.vim	/^nnoremap ,py :-1read $HOME\/.vim\/snippets\/pyheader.py$/;"	m
,sh	s.vim	/^nnoremap ,sh :-1read $HOME\/.vim\/snippets\/bashheader.sh$/;"	m
<Down>	s.vim	/^imap <Down> <Nop>$/;"	m
<Down>	s.vim	/^map <Down> <Nop>$/;"	m
<Left>	s.vim	/^imap <Left> <Nop>$/;"	m
<Left>	s.vim	/^map <Left> <Nop>$/;"	m
<Plug>NetrwBrowseX	s.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX/;"	m
<Plug>NetrwBrowseXVis	s.vim	/^vnoremap <silent> <Plug>NetrwBrowseXVis :call netrw#BrowseXVis()$/;"	m
<Right>	s.vim	/^imap <Right> <Nop>$/;"	m
<Right>	s.vim	/^map <Right> <Nop>$/;"	m
<Up>	s.vim	/^imap <Up> <Nop>$/;"	m
<Up>	s.vim	/^map <Up> <Nop>$/;"	m
Animate:init	Animate.lua	/^function Animate:init(spriteSheet, frameX, frameY, duration)$/;"	f
Animate:render	Animate.lua	/^function Animate:render()$/;"	f
Animate:update	Animate.lua	/^function Animate:update(dt)$/;"	f
Animation:clone	anim8.lua	/^function Animation:clone()$/;"	f
Animation:draw	anim8.lua	/^function Animation:draw(image, x, y, r, sx, sy, ox, oy, kx, ky)$/;"	f
Animation:flipH	anim8.lua	/^function Animation:flipH()$/;"	f
Animation:flipV	anim8.lua	/^function Animation:flipV()$/;"	f
Animation:getDimensions	anim8.lua	/^function Animation:getDimensions()$/;"	f
Animation:getFrameInfo	anim8.lua	/^function Animation:getFrameInfo(x, y, r, sx, sy, ox, oy, kx, ky)$/;"	f
Animation:gotoFrame	anim8.lua	/^function Animation:gotoFrame(position)$/;"	f
Animation:pause	anim8.lua	/^function Animation:pause()$/;"	f
Animation:pauseAtEnd	anim8.lua	/^function Animation:pauseAtEnd()$/;"	f
Animation:pauseAtStart	anim8.lua	/^function Animation:pauseAtStart()$/;"	f
Animation:resume	anim8.lua	/^function Animation:resume()$/;"	f
Animation:update	anim8.lua	/^function Animation:update(dt)$/;"	f
Class:extend	class.lua	/^function Class:extend(obj)$/;"	f
Class:init	class.lua	/^function Class:init(...) end$/;"	f
Class:new	class.lua	/^function Class:new(...)$/;"	f
Class:set	class.lua	/^function Class:set(prop, value)$/;"	f
Grid:getFrames	anim8.lua	/^function Grid:getFrames(...)$/;"	f
HUD:init	HUD.lua	/^function HUD:init()$/;"	f
HUD:render	HUD.lua	/^function HUD:render()$/;"	f
HUD:update	HUD.lua	/^function HUD:update()$/;"	f
Items:add	Items.lua	/^function Items:add(itemName, itemX, itemY)$/;"	f
Items:init	Items.lua	/^function Items:init(itemSheet, itemFrameX, itemFrameY, itemDuration, itemFrames)$/;"	f
Items:remove	Items.lua	/^function Items:remove(item)$/;"	f
Items:render	Items.lua	/^function Items:render(x, y)$/;"	f
Items:update	Items.lua	/^function Items:update(dt)$/;"	f
SessionLoad	s.vim	/^let SessionLoad = 1$/;"	v
Tiles:getCurrentTile	Tiles.lua	/^function Tiles:getCurrentTile(x, y)$/;"	f
Tiles:getTileXY	Tiles.lua	/^function Tiles:getTileXY(thisTile)$/;"	f
Tiles:init	Tiles.lua	/^function Tiles:init(tileSheet, tileWidth, tileHeight)$/;"	f
Tiles:isonGround	Tiles.lua	/^function Tiles:isonGround(x, y)$/;"	f
Tiles:render	Tiles.lua	/^function Tiles:render()$/;"	f
World:add	bump.lua	/^function World:add(item, x,y,w,h)$/;"	f
World:addResponse	bump.lua	/^function World:addResponse(name, response)$/;"	f
World:check	bump.lua	/^function World:check(item, goalX, goalY, filter)$/;"	f
World:countCells	bump.lua	/^function World:countCells()$/;"	f
World:countItems	bump.lua	/^function World:countItems()$/;"	f
World:getItems	bump.lua	/^function World:getItems()$/;"	f
World:getRect	bump.lua	/^function World:getRect(item)$/;"	f
World:hasItem	bump.lua	/^function World:hasItem(item)$/;"	f
World:move	bump.lua	/^function World:move(item, goalX, goalY, filter)$/;"	f
World:project	bump.lua	/^function World:project(item, x,y,w,h, goalX, goalY, filter)$/;"	f
World:queryPoint	bump.lua	/^function World:queryPoint(x,y, filter)$/;"	f
World:queryRect	bump.lua	/^function World:queryRect(x,y,w,h, filter)$/;"	f
World:querySegment	bump.lua	/^function World:querySegment(x1, y1, x2, y2, filter)$/;"	f
World:querySegmentWithCoords	bump.lua	/^function World:querySegmentWithCoords(x1, y1, x2, y2, filter)$/;"	f
World:remove	bump.lua	/^function World:remove(item)$/;"	f
World:toCell	bump.lua	/^function World:toCell(x,y)$/;"	f
World:toWorld	bump.lua	/^function World:toWorld(cx, cy)$/;"	f
World:update	bump.lua	/^function World:update(item, x2,y2,w2,h2)$/;"	f
\\g	s.vim	/^map \\g :wa!$/;"	m
\\l	s.vim	/^map \\l :wa!$/;"	m
addItemToCell	bump.lua	/^local function addItemToCell(self, item, cx, cy)$/;"	f
assertIsPositiveNumber	bump.lua	/^local function assertIsPositiveNumber(value, name)$/;"	f
assertIsRect	bump.lua	/^local function assertIsRect(x,y,w,h)$/;"	f
assertPositiveInteger	anim8.lua	/^local function assertPositiveInteger(value, name)$/;"	f
assertType	bump.lua	/^local function assertType(desiredType, value, name)$/;"	f
bounce	bump.lua	/^local bounce = function(world, col, x,y,w,h, goalX, goalY, filter)$/;"	f
bump.newWorld	bump.lua	/^bump.newWorld = function(cellSize)$/;"	f
class	class.lua	/^function class(attr)$/;"	f
cloneArray	anim8.lua	/^local function cloneArray(arr)$/;"	f
copyTable	class.lua	/^	local function copyTable(table, destination)$/;"	f
createFrame	anim8.lua	/^local function createFrame(self, x, y)$/;"	f
cross	bump.lua	/^local cross = function(world, col, x,y,w,h, goalX, goalY, filter)$/;"	f
defaultFilter	bump.lua	/^local defaultFilter = function()$/;"	f
f	anim8.lua	/^    local f = type(self.onLoop) == 'function' and self.onLoop or self[self.onLoop]$/;"	f
getCellsTouchedBySegment	bump.lua	/^local function getCellsTouchedBySegment(self, x1,y1,x2,y2)$/;"	f
getDictItemsInCellRect	bump.lua	/^local function getDictItemsInCellRect(self, cl,ct,cw,ch)$/;"	f
getGridKey	anim8.lua	/^local function getGridKey(...)$/;"	f
getInfoAboutItemsTouchedBySegment	bump.lua	/^local function getInfoAboutItemsTouchedBySegment(self, x1,y1, x2,y2, filter)$/;"	f
getOrCreateFrame	anim8.lua	/^local function getOrCreateFrame(self, x, y)$/;"	f
getResponseByName	bump.lua	/^local function getResponseByName(self, name)$/;"	f
grid_toCell	bump.lua	/^local function grid_toCell(cellSize, x, y)$/;"	f
grid_toCellRect	bump.lua	/^local function grid_toCellRect(cellSize, x,y,w,h)$/;"	f
grid_toWorld	bump.lua	/^local function grid_toWorld(cellSize, cx, cy)$/;"	f
grid_traverse	bump.lua	/^local function grid_traverse(cellSize, x1,y1,x2,y2, f)$/;"	f
grid_traverse_initStep	bump.lua	/^local function grid_traverse_initStep(cellSize, ct, t1, t2)$/;"	f
gx	s.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
gx	s.vim	/^vmap gx <Plug>NetrwBrowseXVis$/;"	m
love.draw	main.lua	/^function love.draw()$/;"	f
love.keypressed	main.lua	/^function love.keypressed(key)$/;"	f
love.load	main.lua	/^function love.load()$/;"	f
love.resize	main.lua	/^function love.resize(w, h)$/;"	f
love.update	main.lua	/^function love.update(dt)$/;"	f
mt.__call	class.lua	/^	mt.__call = function(self, ...)$/;"	f
mt.__index	class.lua	/^	mt.__index = function(table, key)$/;"	f
mt.__newindex	class.lua	/^	mt.__newindex = function(table, key, value)$/;"	f
nearest	bump.lua	/^local function nearest(x, a, b)$/;"	f
newAnimation	anim8.lua	/^local function newAnimation(frames, durations, onLoop)$/;"	f
newGrid	anim8.lua	/^local function newGrid(frameWidth, frameHeight, imageWidth, imageHeight, left, top, border)$/;"	f
nop	anim8.lua	/^local nop = function() end$/;"	f
parseDurations	anim8.lua	/^local function parseDurations(durations, frameCount)$/;"	f
parseInterval	anim8.lua	/^local function parseInterval(str)$/;"	f
parseIntervals	anim8.lua	/^local function parseIntervals(durations)$/;"	f
playerFilter	main.lua	/^playerFilter = function(item, other)$/;"	f
push:addCanvas	push.lua	/^function push:addCanvas(params)$/;"	f
push:apply	push.lua	/^function push:apply(operation, shader)$/;"	f
push:applySettings	push.lua	/^function push:applySettings(settings)$/;"	f
push:applyShaders	push.lua	/^function push:applyShaders(canvas, shaders)$/;"	f
push:finish	push.lua	/^function push:finish(shader)$/;"	f
push:getCanvasTable	push.lua	/^function push:getCanvasTable(name)$/;"	f
push:getDimensions	push.lua	/^function push:getDimensions() return self._WWIDTH, self._WHEIGHT end$/;"	f
push:getHeight	push.lua	/^function push:getHeight() return self._WHEIGHT end$/;"	f
push:getWidth	push.lua	/^function push:getWidth() return self._WWIDTH end$/;"	f
push:initValues	push.lua	/^function push:initValues()$/;"	f
push:resetSettings	push.lua	/^function push:resetSettings() return self:applySettings(self.defaults) end$/;"	f
push:resize	push.lua	/^function push:resize(w, h)$/;"	f
push:setBorderColor	push.lua	/^function push:setBorderColor(color, g, b)$/;"	f
push:setCanvas	push.lua	/^function push:setCanvas(name)$/;"	f
push:setShader	push.lua	/^function push:setShader(name, shader)$/;"	f
push:setupCanvas	push.lua	/^function push:setupCanvas(canvases)$/;"	f
push:setupScreen	push.lua	/^function push:setupScreen(WWIDTH, WHEIGHT, RWIDTH, RHEIGHT, settings)$/;"	f
push:start	push.lua	/^function push:start()$/;"	f
push:switchFullscreen	push.lua	/^function push:switchFullscreen(winw, winh)$/;"	f
push:toGame	push.lua	/^function push:toGame(x, y)$/;"	f
push:toReal	push.lua	/^function push:toReal(x, y)$/;"	f
rect_containsPoint	bump.lua	/^local function rect_containsPoint(x,y,w,h, px,py)$/;"	f
rect_detectCollision	bump.lua	/^local function rect_detectCollision(x1,y1,w1,h1, x2,y2,w2,h2, goalX, goalY)$/;"	f
rect_getDiff	bump.lua	/^local function rect_getDiff(x1,y1,w1,h1, x2,y2,w2,h2)$/;"	f
rect_getNearestCorner	bump.lua	/^local function rect_getNearestCorner(x,y,w,h, px, py)$/;"	f
rect_getSegmentIntersectionIndices	bump.lua	/^local function rect_getSegmentIntersectionIndices(x,y,w,h, x1,y1,x2,y2, ti1,ti2)$/;"	f
rect_getSquareDistance	bump.lua	/^local function rect_getSquareDistance(x1,y1,w1,h1, x2,y2,w2,h2)$/;"	f
rect_isIntersecting	bump.lua	/^local function rect_isIntersecting(x1,y1,w1,h1, x2,y2,w2,h2)$/;"	f
removeItemFromCell	bump.lua	/^local function removeItemFromCell(self, item, cx, cy)$/;"	f
s:cpo_save	s.vim	/^let s:cpo_save=&cpo$/;"	v
s:l	s.vim	/^let s:l = 1 - ((0 * winheight(0) + 28) \/ 56)$/;"	v
s:l	s.vim	/^let s:l = 24 - ((23 * winheight(0) + 28) \/ 56)$/;"	v
s:l	s.vim	/^let s:l = 26 - ((25 * winheight(0) + 28) \/ 56)$/;"	v
s:l	s.vim	/^let s:l = 6 - ((5 * winheight(0) + 28) \/ 56)$/;"	v
s:l	s.vim	/^let s:l = 8 - ((7 * winheight(0) + 28) \/ 56)$/;"	v
s:so_save	s.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:sx	s.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:wipebuf	s.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
scratch	README.md	/^# scratch$/;"	c
seekFrameIndex	anim8.lua	/^local function seekFrameIndex(intervals, timer)$/;"	f
sign	bump.lua	/^local function sign(x)$/;"	f
slide	bump.lua	/^local slide = function(world, col, x,y,w,h, goalX, goalY, filter)$/;"	f
sortByTiAndDistance	bump.lua	/^local function sortByTiAndDistance(a,b)$/;"	f
sortByWeight	bump.lua	/^local function sortByWeight(a,b) return a.weight < b.weight end$/;"	f
touch	bump.lua	/^local touch = function(world, col, x,y,w,h, goalX, goalY, filter)$/;"	f
visitedFilter	bump.lua	/^  local visitedFilter = function(itm, other)$/;"	f
windowUpdateMode	push.lua	/^local windowUpdateMode = love11 and love.window.updateMode or function(width, height, settings)$/;"	f
